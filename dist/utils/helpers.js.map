{"version":3,"file":"helpers.js","sourceRoot":"src/","sources":["utils/helpers.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,oDAA4B;AAE5B,gEAA+B;AAE/B,gDAAmD;AACnD,yDAAmC;AAGnC,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,eAAe,EAAE,SAAS,EAAE,GAAG,iBAAS,CAAC;AAEzE,SAAsB,YAAY,CAChC,QAAiC,EACjC,GAAa;;QAEb,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,MAAM,QAAQ,EAAE,CAAC;YAChC,OAAO,MAAM,CAAC;QAChB,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACb,IAAA,yBAAc,EAAC;gBACb,GAAG;gBACH,GAAG;gBACH,OAAO,EAAE,2BAA2B,GAAG,CAAC,OAAO,EAAE;gBACjD,MAAM,EAAE,GAAG;aACZ,CAAC,CAAC;QACL,CAAC;IACH,CAAC;CAAA;AAfD,oCAeC;AAED,SAAsB,YAAY,CAAC,QAAgB;;QACjD,MAAM,IAAI,GAAG,MAAM,gBAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;QAC9C,OAAO,MAAM,gBAAM,CAAC,IAAI,CAAC,QAAQ,GAAG,UAAU,EAAE,IAAI,CAAC,CAAC;IACxD,CAAC;CAAA;AAHD,oCAGC;AAED,SAAsB,eAAe,CACnC,aAAqB,EACrB,cAAsB;;QAEtB,OAAO,gBAAM,CAAC,WAAW,CAAC,aAAa,GAAG,UAAU,EAAE,cAAc,CAAC,CAAC;IACxE,CAAC;CAAA;AALD,0CAKC;AAED,SAAgB,aAAa,CAAC,EAC5B,IAAI,EACJ,SAAS,GAAG,eAAe,EAC3B,QAAQ,GAAG,KAAK,GAKjB;IACC,OAAO,sBAAG,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,EAAE;QAC/B,SAAS;QACT,MAAM,EAAE,kBAAkB;QAC1B,QAAQ,EAAE,GAAG,QAAQ,OAAO;KAC7B,CAAC,CAAC;AACL,CAAC;AAdD,sCAcC","sourcesContent":["import bcrypt from \"bcrypt\";\nimport { Response } from \"express\";\nimport jwt from \"jsonwebtoken\";\n\nimport { handleResponse } from \"../utils/response\";\nimport appConfig from \"../configs\";\nimport { IToken } from \"./types\";\n\nconst { saltRounds, hashPepper, sessionLifeSpan, jwtSecret } = appConfig;\n\nexport async function asyncWrapper(\n  callback: () => Promise<Response>,\n  res: Response\n) {\n  try {\n    const result = await callback();\n    return result;\n  } catch (err) {\n    handleResponse({\n      res,\n      err,\n      message: `Internal Server Error:  ${err.message}`,\n      status: 500,\n    });\n  }\n}\n\nexport async function hashPassword(password: string) {\n  const salt = await bcrypt.genSalt(saltRounds);\n  return await bcrypt.hash(password + hashPepper, salt);\n}\n\nexport async function comparePassword(\n  plainPassword: string,\n  hashedPassword: string\n) {\n  return bcrypt.compareSync(plainPassword + hashPepper, hashedPassword);\n}\n\nexport function generateToken({\n  data,\n  expiresIn = sessionLifeSpan,\n  audience = \"web\",\n}: {\n  data: IToken;\n  expiresIn?: number;\n  audience?: \"web\" | \"app\";\n}) {\n  return jwt.sign(data, jwtSecret, {\n    expiresIn,\n    issuer: `speedycardLister`,\n    audience: `${audience}-user`,\n  });\n}\n"]}